package won.cryptography.rdfsign;

import java.security.PublicKey;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.jena.query.Dataset;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StopWatch;

import won.cryptography.utils.TestSigningUtils;
import won.cryptography.utils.TestingKeys;
import won.protocol.message.WonMessage;
import won.protocol.message.processor.impl.WonMessageSignerVerifier;
import won.protocol.util.RdfUtils;
import won.protocol.vocabulary.WONMSG;

/**
 * User: ypanchenko Date: 14.07.2014
 */
public class WonSignerTest {
    private final Logger logger = LoggerFactory.getLogger(getClass());
    private static final String RESOURCE_FILE = "/won-signed-messages/create-atom-msg.trig";
    private static final String ATOM_CORE_DATA_URI = "http://localhost:8080/won/resource/atom/3144709509622353000/core/#data";
    private static final String ATOM_CORE_DATA_SIG_URI = "http://localhost:8080/won/resource/atom/3144709509622353000/core/#data-sig";
    private static final String EVENT_ENV1_URI = "http://localhost:8080/won/resource/event/7719577021233193000#data";
    private static final String EVENT_ENV1_SIG_URI = "http://localhost:8080/won/resource/event/7719577021233193000#data-sig";
    private static final String EVENT_ENV2_URI = "http://localhost:8080/won/resource/event/7719577021233193000#envelope-s7gl";
    private static final String EVENT_ENV2_SIG_URI = "http://localhost:8080/won/resource/event/7719577021233193000#envelope-s7gl-sig";
    private TestingKeys keys;

    @Before
    public void init() throws Exception {
        keys = new TestingKeys(TestSigningUtils.KEYS_FILE);
    }

    @Test
    @Ignore
    public void testSignCreatedAtom() throws Exception {
        // create dataset that contains atom core data graph
        Dataset testDataset = TestSigningUtils.prepareTestDatasetFromNamedGraphs(RESOURCE_FILE,
                        new String[] { ATOM_CORE_DATA_URI });
        // sign it
        WonSigner signer = new WonSigner(testDataset);
        signer.signNamedGraphsSeparately(keys.getPrivateKey(TestSigningUtils.atomCertUri), TestSigningUtils.atomCertUri,
                        keys.getPublicKey(TestSigningUtils.atomCertUri), ATOM_CORE_DATA_URI);
        // write for debugging
        // TestSigningUtils.writeToTempFile(testDataset);
        // extract names of the named graphs
        List<String> namesList = RdfUtils.getModelNames(testDataset);
        // do some checks to make sure the signatures are added
        Assert.assertEquals(2, namesList.size());
        Assert.assertTrue(namesList.contains(ATOM_CORE_DATA_URI));
        Assert.assertTrue(namesList.contains(ATOM_CORE_DATA_SIG_URI));
        int triplesCounter = TestSigningUtils
                        .countTriples(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI).listStatements());
        Assert.assertEquals(11, triplesCounter);
        String sigValue = TestSigningUtils.getObjectOfPredAsString(testDataset.getNamedModel(ATOM_CORE_DATA_SIG_URI),
                        WONMSG.signatureValue.getURI());
        // even with the same key the signature for the same input is different each
        // time due to the random
        // integer used by the elliptic curve signing algorithm, therefore, we cannot
        // really test here properly
        // if the signature is correct
        Assert.assertTrue(sigValue.length() > 75);
    }

    @Test
    @Ignore
    // test signing the event that already contains graph with corresponding graph
    // signature
    public void testSignCreatedAtomOwnerEvent() throws Exception {
        // create dataset that contains atom core data graph, its signature, and message
        // envelope generated by the owner
        Dataset testDataset = TestSigningUtils.prepareTestDatasetFromNamedGraphs(RESOURCE_FILE,
                        new String[] { ATOM_CORE_DATA_URI, ATOM_CORE_DATA_SIG_URI, EVENT_ENV1_URI });
        // sign it
        WonSigner signer = new WonSigner(testDataset);
        signer.signNamedGraphsSeparately(keys.getPrivateKey(TestSigningUtils.atomCertUri), TestSigningUtils.atomCertUri,
                        keys.getPublicKey(TestSigningUtils.atomCertUri), EVENT_ENV1_URI);
        // write for debugging
        // TestSigningUtils.writeToTempFile(testDataset);
        // extract names of the named graphs
        List<String> namesList = RdfUtils.getModelNames(testDataset);
        // do some checks to make sure the signatures are added
        Assert.assertEquals(4, namesList.size());
        Assert.assertTrue(namesList.contains(EVENT_ENV1_URI));
        Assert.assertTrue(namesList.contains(EVENT_ENV1_SIG_URI));
        int triplesCounter = TestSigningUtils
                        .countTriples(testDataset.getNamedModel(EVENT_ENV1_SIG_URI).listStatements());
        Assert.assertEquals(11, triplesCounter);
        String sigValue = TestSigningUtils.getObjectOfPredAsString(testDataset.getNamedModel(EVENT_ENV1_SIG_URI),
                        "http://icp.it-risk.iwvi.uni-koblenz.de/ontologies/signature" + ".owl#hasSignatureValue");
        // even with the same key the signature for the same input is different each
        // time due to the random
        // integer used by the elliptic curve signing algorithm, therefore, we cannot
        // really test here properly
        // if the signature is correct
        Assert.assertTrue(sigValue.length() > 75);
    }

    @Test
    @Ignore
    public void testSignCreatedAtomNodeEvent() throws Exception {
        // create dataset that contains atom core data graph, its signature, message
        // envelope generated by the owner,
        // its signature, and message envelope generated by the node
        Dataset testDataset = TestSigningUtils.prepareTestDatasetFromNamedGraphs(RESOURCE_FILE,
                        new String[] { ATOM_CORE_DATA_URI, ATOM_CORE_DATA_SIG_URI, EVENT_ENV1_URI, EVENT_ENV1_SIG_URI,
                                        EVENT_ENV2_URI });
        // sign it
        WonSigner signer = new WonSigner(testDataset);
        signer.signNamedGraphsSeparately(keys.getPrivateKey(TestSigningUtils.nodeCertUri), TestSigningUtils.nodeCertUri,
                        keys.getPublicKey(TestSigningUtils.nodeCertUri), EVENT_ENV2_URI);
        // write for debugging
        TestSigningUtils.writeToTempFile(testDataset);
        // verify
        WonVerifier verifier = new WonVerifier(WonMessage.of(testDataset));
        boolean verified = verifier.verify(keys.getPublicKeys());
        SignatureVerificationState result = verifier.getVerificationResult();
        Assert.assertTrue(result.getMessage(), verified);
        // extract names of the named graphs
        List<String> namesList = RdfUtils.getModelNames(testDataset);
        // do some checks to make sure the signatures are added
        Assert.assertEquals(6, namesList.size());
        Assert.assertTrue(namesList.contains(EVENT_ENV2_URI));
        Assert.assertTrue(namesList.contains(EVENT_ENV2_SIG_URI));
        int triplesCounter = TestSigningUtils
                        .countTriples(testDataset.getNamedModel(EVENT_ENV2_SIG_URI).listStatements());
        Assert.assertEquals(11, triplesCounter);
        String sigValue = TestSigningUtils.getObjectOfPredAsString(testDataset.getNamedModel(EVENT_ENV2_SIG_URI),
                        "http://icp.it-risk.iwvi.uni-koblenz.de/ontologies/signature" + ".owl#hasSignatureValue");
        // even with the same key the signature for the same input is different each
        // time due to the random
        // integer used by the elliptic curve signing algorithm, therefore, we cannot
        // really test here properly
        // if the signature is correct
        Assert.assertTrue(sigValue.length() > 75);
    }

    @Test
    public void signerVerifierSpeedTest() throws Exception {
        StopWatch sw = new StopWatch();
        for (int i = 0; i < 5; i++) {
            Dataset dataset = TestSigningUtils.prepareTestDataset("/createMessage.trig");
            WonMessage message = WonMessage.of(dataset);
            sw.start("signing");
            WonMessage signed = WonMessageSignerVerifier.sign(keys.getPrivateKey(TestSigningUtils.atomCertUri),
                            keys.getPublicKey(TestSigningUtils.atomCertUri), TestSigningUtils.atomCertUri, message);
            sw.stop();
            sw.start("verifying");
            Map<String, PublicKey> keyForVerification = new HashMap<>();
            keyForVerification.put(TestSigningUtils.atomCertUri, keys.getPublicKey(TestSigningUtils.atomCertUri));
            SignatureVerificationState result = WonMessageSignerVerifier.verify(keyForVerification, signed);
            System.out.println("results: " + result.isVerificationPassed());
            sw.stop();
        }
        logger.debug(sw.prettyPrint());
    }
}
