package won.cryptography.rdfsign;

import com.hp.hpl.jena.query.Dataset;
import de.uni_koblenz.aggrimm.icp.crypto.sign.algorithm.algorithm.SignatureAlgorithmFisteus2010;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import won.cryptography.service.KeyStoreService;
import won.cryptography.utils.TestSigningUtils;
import won.protocol.util.RdfUtils;

import java.io.File;
import java.security.PrivateKey;
import java.security.Security;
import java.security.interfaces.ECPrivateKey;
import java.util.List;

/**
 * User: ypanchenko
 * Date: 14.07.2014
 */
public class WonSignerTest
{

  private static final String RESOURCE_FILE = "/won-signed-messages/create-need-msg.trig";

  private static final String NEED_CORE_DATA_URI =
    "http://localhost:8080/won/resource/need/3144709509622353000/core/#data";
  private static final String NEED_CORE_DATA_SIG_URI =
    "http://localhost:8080/won/resource/need/3144709509622353000/core/#data-sig";

  private static final String EVENT_ENV1_URI =
    "http://localhost:8080/won/resource/event/7719577021233193000#data";
  private static final String EVENT_ENV1_SIG_URI =
    "http://localhost:8080/won/resource/event/7719577021233193000#data-sig";

  private static final String EVENT_ENV2_URI =
    "http://localhost:8080/won/resource/event/7719577021233193000#envelope-s7gl";
  private static final String EVENT_ENV2_SIG_URI =
    "http://localhost:8080/won/resource/event/7719577021233193000#envelope-s7gl-sig";


  private PrivateKey needKey;
  private String needCertUri;
  private PrivateKey ownerKey;
  private String ownerCertUri;
  private PrivateKey nodeKey;
  private String nodeCertUri;

  @Before
  public void init() {
    Security.addProvider(new BouncyCastleProvider());

    //load private  keys:
    File keysFile = new File(this.getClass().getResource(TestSigningUtils.KEYS_FILE).getFile());
    KeyStoreService storeService = new KeyStoreService(keysFile);

    this.needKey = (ECPrivateKey) storeService.getPrivateKey(TestSigningUtils.NEED_KEY_NAME);
    // do we need owner key for some messages? e.g. when we send an error occurred
    // message not generated by owner client but by owner server?
    this.ownerKey = (ECPrivateKey) storeService.getPrivateKey(TestSigningUtils.OWNER_KEY_NAME);
    this.nodeKey = (ECPrivateKey) storeService.getPrivateKey(TestSigningUtils.NODE_KEY_NAME);

    // TODO load from file
    needCertUri = "http://localhost:8080/won/resource/need/3144709509622353000/#certificate";
    ownerCertUri = "http://localhost:8080/owner/certificate";
    nodeCertUri = "http://localhost:8080/node/certificate";

    //java.security.cert.Certificate cert = storeService.getCertificate("TEST-NEED-KEY");
    //this.needPublicKey = cert.getPublicKey();
  }

  @Test
  public void testSignCreatedNeed() throws Exception {

    // create dataset that contains need core data graph
    Dataset testDataset = TestSigningUtils.prepareTestDatasetFromNamedGraphs(RESOURCE_FILE,
                                                                             new String[]{NEED_CORE_DATA_URI});

    // sign it
    WonSigner signer = new WonSigner(testDataset, new SignatureAlgorithmFisteus2010());
    signer.sign(needKey, needCertUri);

    // write for debugging
    //TestSigningUtils.writeToTempFile(testDataset);

    // extract names of the named graphs
    List<String> namesList = RdfUtils.getModelNames(testDataset);
    // do some checks to make sure the signatures are added
    Assert.assertEquals(2, namesList.size());
    Assert.assertTrue(namesList.contains(NEED_CORE_DATA_URI));
    Assert.assertTrue(namesList.contains(NEED_CORE_DATA_SIG_URI));
    int triplesCounter = TestSigningUtils.countTriples(testDataset.getNamedModel(NEED_CORE_DATA_SIG_URI)
                                                                  .listStatements());
    Assert.assertEquals(11, triplesCounter);
    String sigValue = TestSigningUtils.getObjectOfPredAsString(testDataset.getNamedModel(NEED_CORE_DATA_SIG_URI),
                                                               "http://icp.it-risk.iwvi.uni-koblenz.de/ontologies/signature" +
                                                                 ".owl#hasSignatureValue");
    // even with the same key the signature for the same input is different each time due to the random
    // integer used by the elliptic curve signing algorithm, therefore, we cannot really test here properly
    // if the signature is correct
    Assert.assertTrue(sigValue.length() > 75);
  }

  @Test
  // test signing the event that already contains graph with corresponding graph signature
  public void testSignCreatedNeedOwnerEvent() throws Exception {
    // create dataset that contains need core data graph, its signature, and message envelope generated by the owner
    Dataset testDataset = TestSigningUtils.prepareTestDatasetFromNamedGraphs(RESOURCE_FILE,
                                                                             new String[]{NEED_CORE_DATA_URI,
                                                                                          NEED_CORE_DATA_SIG_URI,
                                                                                          EVENT_ENV1_URI});

    // sign it
    WonSigner signer = new WonSigner(testDataset, new SignatureAlgorithmFisteus2010());
    signer.sign(needKey, needCertUri, new String[]{EVENT_ENV1_URI});

    // write for debugging
    //TestSigningUtils.writeToTempFile(testDataset);

    // extract names of the named graphs
    List<String> namesList = RdfUtils.getModelNames(testDataset);
    // do some checks to make sure the signatures are added
    Assert.assertEquals(4, namesList.size());
    Assert.assertTrue(namesList.contains(EVENT_ENV1_URI));
    Assert.assertTrue(namesList.contains(EVENT_ENV1_SIG_URI));
    int triplesCounter = TestSigningUtils.countTriples(testDataset.getNamedModel(EVENT_ENV1_SIG_URI).listStatements());
    Assert.assertEquals(11, triplesCounter);
    String sigValue = TestSigningUtils.getObjectOfPredAsString(testDataset.getNamedModel(EVENT_ENV1_SIG_URI),
                                                               "http://icp.it-risk.iwvi.uni-koblenz.de/ontologies/signature" +
                                                                 ".owl#hasSignatureValue");
    // even with the same key the signature for the same input is different each time due to the random
    // integer used by the elliptic curve signing algorithm, therefore, we cannot really test here properly
    // if the signature is correct
    Assert.assertTrue(sigValue.length() > 75);
  }

  @Test
  public void testSignCreatedNeedNodeEvent() throws Exception {

    // create dataset that contains need core data graph, its signature, message envelope generated by the owner,
    // its signature, and message envelope generated by the node
    Dataset testDataset = TestSigningUtils.prepareTestDatasetFromNamedGraphs(RESOURCE_FILE,
                                                                             new String[]{
                                                                               NEED_CORE_DATA_URI,
                                                                               NEED_CORE_DATA_SIG_URI,
                                                                               EVENT_ENV1_URI, EVENT_ENV1_SIG_URI,
                                                                               EVENT_ENV2_URI
                                                                             });

    // sign it
    WonSigner signer = new WonSigner(testDataset, new SignatureAlgorithmFisteus2010());
    signer.sign(nodeKey, nodeCertUri, new String[]{EVENT_ENV2_URI});

    // write for debugging
    //TestSigningUtils.writeToTempFile(testDataset);

    // extract names of the named graphs
    List<String> namesList = RdfUtils.getModelNames(testDataset);
    // do some checks to make sure the signatures are added
    Assert.assertEquals(6, namesList.size());
    Assert.assertTrue(namesList.contains(EVENT_ENV2_URI));
    Assert.assertTrue(namesList.contains(EVENT_ENV2_SIG_URI));
    int triplesCounter = TestSigningUtils.countTriples(testDataset.getNamedModel(EVENT_ENV2_SIG_URI).listStatements());
    Assert.assertEquals(11, triplesCounter);
    String sigValue = TestSigningUtils.getObjectOfPredAsString(testDataset.getNamedModel(EVENT_ENV2_SIG_URI),
                                                               "http://icp.it-risk.iwvi.uni-koblenz.de/ontologies/signature" +
                                                                 ".owl#hasSignatureValue");
    // even with the same key the signature for the same input is different each time due to the random
    // integer used by the elliptic curve signing algorithm, therefore, we cannot really test here properly
    // if the signature is correct
    Assert.assertTrue(sigValue.length() > 75);

  }


}
