# Stating Information Requirements

This document describes a possible approach for how owners can request information from their counterparts.

The basic idea is that an owner uses SHACL shapes to specify their information needs. The counterpart then adds data to their communication channel (the connection) or invalidates already added data until the valid data in the channel can be validated by the shape.  

## Variants
Shapes can be used in needs in the following ways:
1. /pre-matching/ - as part of the need description
1. /post-matching/, i.e. during a conversation 
### pre-matching 
1. To specify matching constraints.  This is the case if 
    1. The shape is attached to a `won:seeks` node of the need
    1. The shape specifies the `sh:severity` `sh:Violation` 
    1. such shapes should cause non-matching needs to be filtered out while matching
1. To specify preferences. This is the case if
    1. The shape is attached to a `won:seeks` node of the need
    1. The shape specifies the `sh:severity` `sh:Warning` 
    1. such shapes should cause a penalty for matched needs that do not conform to the shape
1. To specify properties of interest. This is the case if
    1. The shape is attached to a `won:seeks` node of the need
    1. The shape specifies the `sh:severity` `sh:Info` 
    1. such shapes should cause a boost for matched needs that specify the property
1. To specify information required from the counterpart so as to be able to perform an action. This could also be called service specification. This is the case if
    1. The shape is attached to a `won:performs` node that describes an operation the need is able to provide
    1. In this case, the shape's `sh:Severity` is used to convey mandatory (`sh:Violation`) or optional (`sh:Warning`) parameters
    
### post-matching
In this case, the shape is embedded in the content of a message.
1. To specify information required from the counterpart so as to be able to perform an action. This could also be called service specification. This is the case if
    1. The shape is attached to a `[needuri]/won:performs` node that describes an operation the need is able to provide
    1. In this case, the shape's `sh:Severity` is used to convey mandatory (`sh:Violation`) or optional (`sh:Warning`) parameters
1. To specify properties of interest after matching. This is the case if  
    1. The shape is embedded in the content of a message via ´[needuri]/won:seeks´ 
    1. The `sh:severity` is to be interpreted as an indication of urgency/importance or precedence if multiple shapes are present


This document is based on the [SHACL Constraint Language (SHACL) W3C Candidate Recommendation](https://www.w3.org/TR/shacl/)

## Evaluating information requirements
### constructing the shapes graph and the data graph
SHACL specifies how a [data graph](https://www.w3.org/TR/shacl/#data-graph) is validated against a [shapes graph](https://www.w3.org/TR/shacl/#shapes-graph).

In order to validate information requirements, we need to define how the shapes graph and the data graph are to be constructed from the available data:

At any point in time during a conversation between two needs (referred to here as the need and the counterpart), the available data consists of all data crawlable starting from the need and starting from the counterpart. (including need content graphs, need sysinfo graph, need's event container, connection container, connections, connection to counterpart including additional data (like feedback), connection's event container, the need's messages and their remoteMessages, the counterpart's messages and their remoteMessages).

For validating the need's information requirements:
* data graph: Compute the union of all triples in the available data that were generated by the counterpart: the counterpart itself (all graphs), as well as all messages that has its connection as the object of the `msg:hasSender` property, fetched from the need's WoN node (i.e. the remoteMessages of the messages produced by the counterpart)
* shapes graph: Compute the union of all graphs in the need that are referenced by [Need] won:hasCounterpartShapesGraph [Graph]

For validating the counterpart's information requirements:
* data graph: Compute the union of all triples in the available data that were generated by the need: the need itself (all graphs), as well as all messages that has its connection as the object of the `msg:hasSender` property, fetched from the need's WoN node (i.e. the originals of the messages produced by the need)
* shapes graph: Compute the union of all graphs in the counterpart that are referenced by [Counterpart] won:hasCounterpartShapesGraph [Graph]

This way, both sides can evaluate each other's information requirements and generate a GUI (e.g. a form, a map, or a calendar) for the user to enter the data.

## Goals

Needs can declare goals that they want to achieve in collaboration with a counterpart need. For example, one need offers a taxi ride and the other needs is looking for a ride. This situation may be described as two complementary goals by the two needs which can result in a collaboration to fulfill actually a common goal of both - perform the ride togehter as driver and client. 

As described before needs are matched based on the data in their `won:is` and `won:seeks` branches. A third type of top level branch therefore is `won:goal`. A goal consists of data graph as input suggestion for the goal and a SHACL graph that defines how the data should look like after the goal is reached. Needs try to fulfill their goals in a conversation with a counterpart need after the matching happened and a connection is opened. Needs would look on the counterpart for fitting complementary goals where the data graph would fulfill the SHACL graph of its own goal(s) and where they can fulfill the SHACL shapes graph on the counterpart with their own data graph in reverse. To fullfill two goals on both both sides one need would propose a data graph that satisfies both SHACL constraints. This data graph would usually be a combination of data graphs of goals of both sides. The other side could then accept the proposed data graph if it satisfies one of its goals and thereby form an agreement with its counterpart need.  

This structure of goals can be used to agree on actions like service/API calls executed by bots that mange needs. For instance, a bot could create a need that describes the input data for a certain API call (e.g. organize a ride and a call taxi) in its goals SHACL shape graph (e.g. specifying that there must be at least be a pickup location and optionally a time provided). It may for example use its own data graph in the goal to specify that the default time for pickup is in 10 minutes from now. 

### Declaring Goals

Needs can declare zero or more goals in top level branches using the property `won:goal`. Each goal has one property `won:hasShapesGraph` attached to it that defines the expected outcome data of the goal. Optionally each goal has another property `won:hasDataGraph` attached to it that defines the input data to support the satisfaction of the goal. 

The following example defines a need that offers "Taxi in Vienna" with a goal declaration to find out the pickup location of potential clients. In the `:needGraph` graph the need is defined having a `won:is` top level branch that describes it for the matching. Also the need defines one goal using another top level branch element `won:goal`. 

The data graph `:service-pickup-data-graph` describes a node that should be of type `taxi:Ride` and sets the driver role to its own need uri as well as a default pickup time to 10 minutes from now. If requested the pickup time data can be overwritten by the client, but it describes the default case where a client usually orders a taxi and wants it immediately if no time is specified explicitly. 

The shapes graph `:service-pickup-shapes-graph` defines that there must be exactly one node of class `taxi:Ride`. The ride specifies exactly one driver which must be `need:taxiOfferNeed` as well as exacly one client which must be the counterpart need uri `need:taxiDemandNeed`. Also the ride must have exactly one `taxi:hasPickUpLocation` property which describes the pickup either as location (e.g. geo coordinates) or address (e.g. name and number of street). Also there must be exactly one property `taxi:hasPickUpDateTime` attached to the `taxi:Ride` node that describes the pickup date and time. A taxi bot could use the default time specified in its own data graph (now + 10 min which has to be updated regularly) or the time from the client need data graph if provided instead. 

Furthermore the shapes graph defines that the `taxi:Ride` is `sh:closed true`. That means the shapes graph will only validate successfully if the proposed data graph has excatly the from described above with no additional properties. This way the taxi service bot can make sure that the agreement doesn't contain unkown triples before accepting it and that the call to the taxi service API can be made with all necessary parameters. 

````
GRAPH :needGraph {
  need:taxiOfferNeed
  a won:Need;
  won:is [
    dc:title "Taxi in Vienna";
    dc:description "Offering taxi services in Vienna and around";
    won:hasLocation  [
      a  s:Place ;
      s:geo [
        a s:GeoCoordinates ;
        s:latitude   "48.209269" ;
        s:longitude  "16.370831"
      ] ;
      s:name        "Vienna, Austria"
    ] ;
        
  won:goal [
    won:hasDataGraph :service-pickup-data-graph ;
    won:hasShapesGraph :service-pickup-shapes-graph  
  ] .
}
  
GRAPH :service-pickup-data-graph {
  ex1:myRide a taxi:Ride .
  ex1:myRide taxi:hasDriver need:taxiOfferNeed .
  ex1:myRide taxi:hasPickupDateTime "2017-11-22T09:30:00Z"^^xsd:dateTime    # now + 10 min 
}

GRAPH :service-pickup-shapes-graph {
  :pickup-shape
  a sh:NodeShape ;
  sh:label "Required pickup information" ;
  sh:message "The required pickup information could not be found" ;
  sh:targetClass taxi:Ride ; 
  sh:severity sh:Violation ;
  sh:closed true ;
  sh:property [
    sh:path ( taxi:hasPickUpLocation ) ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:or (
      [ sh:node :locationShape ] # details of :locationShape not shown here
      [ sh:node :addressShape ]  # details of :addressShape not shown here
    )
  ] ;
  sh:property [
    sh:path ( taxi:hasDriver ) ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:hasValue need:taxiOfferNeed ;
  ] ;
  sh:property [
    sh:path ( taxi:hasClient ) ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:hasValue need:taxiDemandNeed ;
  ] ;
  sh:property [
    sh:path ( taxi:hasPickUpDateTime ) ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:datatype xsd:dateTime ;
  ] .
}
````

If this taxi service need is matched with a potential client need with compatible goals they could start a collaboration.
The taxi service cannot fulfill its goal just for itself by proposing its `:service-pickup-data-graph` to a client since its shape graph `:service-pickup-shapes-graph` requires a pick up location property of type `taxi:hasPickUpLocation` as well as a client set by the property `taxi:hasClient`. These triples have to be provided by a client to satisfy the taxi services shapes graphs. 

A client need that could have been matched to the above service could look like the following. The need is again described in a `:needGraph` graph but with a `won:seeks` top level branch to match the service need. The need has one goal with a data graph `:client-pickup-data-graph` and a shape graph `client-pickup-data-graph`. 

The data graph specifies a node of type `taxi:Ride` with client, pickup time and location properties. The pickup time is set to the next day and is meant to overwrite the default pickup time in the data graph of the taxi service. For the pickup location an address string is specified. The client is set to the own need uri `need:taxiDemandNeed`.

The shape graph specifies the conditions for the client to accept an agreement with a taxi service provider. As above the `sh:closed` property is used to have control of the triples in the final agreement. As above the client expects the ride to have a driver role that is played by the counterpart need `need:taxiOfferNeed` and a client role with its own need uri `need:taxiDemandNeed`. Also the client expects an `:addressShape` as pickup location with value "Thurngasse, KG Alsergrund, Alsergrund, Wien, 1090, Österreich" which matches exactly the location already specified in its data graph. That means the taxi service should just use this address without modifying anything here. Also the client specifies the constraints for the pickup time in its goals shape graph. The pickup time that the client recommends in its goals data graph must not match exactly the one that the taxi service might propose. The client grants a time window of 10 minutes by specifying `sh:minInclusive` and `sh:maxInclusive` constraints for the `taxi:hasPickUpDateTime`. 


````
GRAPH :needGraph {
  need:taxiDemandNeed
  a won:Need;
  won:seeks [
    dc:title "Looking for a taxi in Vienna" ;
    won:hasLocation [
      a  s:Place ;
      s:name  "Thurngasse, KG Alsergrund, Alsergrund, Wien, 1090, Österreich"
    ] 
  ] ;
    
  won:goal [
    won:hasDataGraph :client-pickup-data-graph ;
    won:hasShapesGraph :client-pickup-shapes-graph 
  ]
}
  
GRAPH :client-pickup-data-graph {
  ex2:myRide a taxi:Ride .
  ex2:myRide taxi:hasClient need:taxiDemandNeed .
  ex2:myRide taxi:hasPickupDateTime "2017-11-23T09:30:00Z"^^xsd:dateTime ;    # same time next day
  ex2:myRide taxi:hasPickUpLocation [
    a  s:Place ;
    s:name  "Thurngasse, KG Alsergrund, Alsergrund, Wien, 1090, Österreich"
  ]
}

GRAPH :client-pickup-shapes-graph {
  :pickup-shape
  a sh:NodeShape ;
  sh:label "Required pickup information" ;
  sh:message "The required pickup information could not be found" ;
  sh:targetClass taxi:Ride ; 
  sh:severity sh:Violation ;
  sh:closed true ;
  sh:property [
    sh:path ( taxi:hasPickUpLocation ) ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:node :addressShape
  ] ;
  sh:property [
    sh:path ( taxi:hasDriver ) ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:hasValue need:taxiOfferNeed ;
  ] ;
  sh:property [
    sh:path ( taxi:hasClient ) ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:hasValue need:taxiDemandNeed ;
  ] ;
  sh:property [
    sh:path ( taxi:hasPickUpDateTime ) ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:datatype xsd:dateTime ;
    sh:minInclusive "2017-11-23T09:25:00Z"^^xsd:dateTime ;   
    sh:maxInclusive "2017-11-23T09:35:00Z"^^xsd:dateTime ;   
  ] .
  
  :addressShape
  a sh:NodeShape ;
  sh:targetClass s:Place ; 
  sh:closed true ;
  sh:property [
    sh:path ( s:name ) ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:hasValue "Thurngasse, KG Alsergrund, Alsergrund, Wien, 1090, Österreich"
  ] .
}
````    
    
### Achieving Goals

Goals can be achieved in collaboration when two needs have established a connection and having a conversation. Either of the two needs can propose a solution for a goal of its counterpart (thereby usually fulfilling a common goal in case a complementary goal exists on its own side that is also fulfilled by the solution) by using the agreement protocol, described in [our DeSemWeb2017 publication](http://ceur-ws.org/Vol-1934/contribution-07.pdf). A solution for a goal is proposed by sending a message with a proposed data graph to the conversation. The following example would be a solution for both goals of the two needs (`taxiOfferNeed` and `taxiDemandNeed`) defined above and could have been sent by the taxi service bot to a client to agree on the specific conditions of the ride. 
    
````
event:event1 agr:propose :pickup-solution .

GRAPH :pickup-solution {
  ex3:myRide a taxi:Ride .
  ex3:myRide taxi:hasDriver need:taxiOfferNeed .
  ex3:myRide taxi:hasClient need:taxiDemandNeed .
  ex3:myRide taxi:hasPickupDateTime "2017-11-23T09:30:00Z"^^xsd:dateTime
  ex3:myRide taxi:hasPickUpLocation [
    a  s:Place ;
    s:name  "Thurngasse, KG Alsergrund, Alsergrund, Wien, 1090, Österreich"
  ]
}
````
    
The `:pickup-solution` is meant to satisfy the shape graph of the client need goal as well as its own goals shape graph. The proposed data graph is usually created by combining the data graphs of the goals of two needs. It can however also be created on-the-fly without any data present in the needs. For example by showing the user a form to enter some values and then creating a data graph to propose to the user.

The proposing need has to make sure that its goals shape graph is satisfied by the proposed data graph. After a data graph has been proposed, it can be accepted (using `agr:accepts` property of the agreement protocol) by the other side. The accepting need also has to make sure that its goals shape graph is satisfied by the proposed data graph before accepting the proposal. Once a proposal is accepted it cannot be canceled without the approval of the counterpart anymore. 

In our example the taxi service bot would combine the data graphs of both needs goals (taxi service and client), check if the shape graphs of both needs goals are satisfied and then propose the data to the client need. The client need would then check if the proposed data satisfies its own goals shape graph and then accept it. However the roles who is proposing and who is accepting could also be changed so that the client proposes data and the taxi service would accept it. Anyway the taxi service bot is able to call a taxi API and order a taxi after the proposal is accepted since its goals shape graph is satisfied which specified the input data needed to make the API call. 

Each side can use `agr:proposeToCancel` and try to cancel an agreement and thereby try to roll back actions that may be started after the agreement was formed (e.g. canceling the taxi order by calling the driver). However as stated before the request has to be accepted by the counterpart if an agreement should be canceled. 


### Blending data graphs

As mentioned above a proposed data graph that is meant to fulfill goals is usually generated by one of the agents by combining the data graphs of one goal from each side of a connection. We call the process of combining two data graphs "blending". 

Blending is neccessary since both side describe their goals from their own perspective and usually use other node URIs to describe concepts that should be the same to talk about the same thing in a mutual agreement. For instance in the above examples the taxi service describes the ride it wants to organize as `ex1:myRide`, the client describe it as `ex2:myRide` and the proposed data graph may even use another URI `ex3:myRide` for the ride node. The point is to come up with a name of the ride that both participants can agree on. Since both participants have not used any restrictions on the ride node name/URI (only refering to the ride as a node of class `taxi:Ride`) in their goals shape graphs, the name of the ride can be changed to blend the data graphs together and satisfy both goals. 

Blending is described in [more detail here.](draft-graph-blending.md) 

## Changes required in current system; design issues

1. Importing needs must be changed to allow for importing datasets (otherwise, we are not able to specify shapes graphs). This would also be required to specify multiple datasets with different access control settings, so this change might be useful for the future.
1. In the case of the factory bot, these needs are factory needs. The bot must be aware of the shape graphs and copy them to the concrete offers.
1. The shapes need to be validated by the bot when it is acting as a bridge to a Web API.
1. The shapes need to be interpreted and validated by the owner application - so it can generate GUI elements asking for values.
    1. investigate further, starting [here](https://lists.w3.org/Archives/Public/public-rdf-shapes/2014Aug/0094.html)
    1. started a [thread in the mailing list](https://lists.w3.org/Archives/Public/public-rdf-shapes/2017May/0039.html)
    1. we'll see
    1. Then again, there is [ShEx](http://shex.io/shex-semantics/index.html) - seems pretty straightforward
1. GUI generation in the owner application will not be available for a long time. So *what can we do instead?*
    1. We actually don' know what the counterpart does with the SHACL shapes it finds in our bot's need. Maybe it has some advanced algorithms evaluating them and then providing more triples, maybe not. We have to wait for messages that improve our validation result.
    1. Such messages would have to contain triples in their content graphs that our shapes are expecting.
        1. simplest solution is to add an imput field for raw RDF data in the owner app.
    1. Alternatively, the counterpart could send messages that tell us to ignore certain graphs that have been sent earlier, because they contained wrong data, or data that is no longer true (such as the current location). The semantics would be 'Graph XY (the one to ignore) is false'.
        1. We have defined how messages can later be retracted in [our DeSemWeb2017 publication](http://ceur-ws.org/Vol-1934/contribution-07.pdf) - we just need to implement that and give it a good GUI
    1. How could the bot could encourage such messages?
        1. Variant A: Keep it simple - show results - wait for triples
            1. validate the current data with the shapes
            1. send the validation result to the counterpart
            1. wait for triples that improve the result or messages that invalidate certain graphs (and thereby improve the result).
        1. Variant B: Question - Suggestion - Question loop (technically more complicated)
            1. validate the current data with the shapes
            1. create plaintext questions based on the validation result
            1. ask the counterpart those questions
            1. The counterpart answers in plain text (i.e. messages with msg:hasTextMessage triples).
            1. The bot generates RDF triples from the response, adds them to the data graph and validates again. If the validation result has improved (fewer problems), the new triples are assumed to be correct. Now they somehow have to be added to the data accepted/asserted by the counterpart.
            1. The bot sends a message to the counterpart that contains the new triples in its content graph. The semantics of the message is a 'suggestion': The bot asks the counterpart to accept these triples as true. The triples are displayed to the counterpart user and she can accept/deny the triples (as a toggle button next to the displayed triples)
            1. In cases of missing triples where default values are present in the SHACL, the bot can suggest the triples using the default values, without even asking a question.
            1. If the user accepts the triples as correct, the counterpart sends a message with the semantics 'Graph XY (the one the bot sent) is true'
        
